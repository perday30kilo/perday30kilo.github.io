# 重读领域驱动设计1-6章


# 对统一语言的理解
![alt 个人理解](https://perday30kilo.github.io/posts/img/ddd-evans-01.png)

# 对于沟通
图是一种沟通和解释的手段，可以促进头脑风暴，简洁的小图能给很好的实现这些目标，涵盖整个对象模型的综合性大图反而是去了沟通或者解释能力，它会让读者淹没在大量细节之中。我们应该避免使用包罗万象的对象模型图，应该使用简化的图，图中只包含对象模型的重要概念。

# Model Driven Design
分析模型和程序设计之间的联系在很多情况下会招到破坏，整个程序设计或者核心部分没有与领域模型相对应，那么这个模型就是没有价值的，软件的正确性也值得怀疑。      
Model Driven Design 提倡的不再将分析模型和程序设计分离开，而是寻求一种能够满足这方面需求的单一模型。即实现所谓的模型和实现的绑定。这也是DDD的核心。
绑定分析模型和实现是可行的，但是我们不能因为技术考虑而去削弱分析的功能，也不能因为领域模型舍弃了软件设计的基本原则。

Hands-On Modeler: 设计模型的人一定要亲身参与编码或者了解编码实现遇到的问题，反过来，负责实现代码的工程师也要理解模型，使用统一语言去讨论模型在实现上的问题。


![alt 个人理解](https://perday30kilo.github.io/posts/img/ddd-evans-02.png)

# 分离领域

![alt 分离领域](https://perday30kilo.github.io/posts/img/ddd-evans-03.png)

将领域层分离开的目的是不让业务核心逻辑（领域）和具体的技术实现绑定在一起。

# Entity 和 Value Object
Enttiy和valueobject本质区别：
entity是用来表示具有连续性和标识的事物，可以追踪它所经历的不同状态，甚至可以跨不同实现跟踪它。    


valueobject是描述某种状态的属性

Service：领域中有些方面适合用动作或者操作来表示，这比用对象更加清楚，这些最好用Service来表示。


# Aggregate
在具有复杂关联的模型中，要想保证对象更改的一致性是很困难的， Aggregate就是一组相关对象的集合，我们把他作为数据修改的单元，每个Aggregate都有一个根和一个边界。
典型的聚合的例子是：车辆，轮胎的例子。
![alt 分离领域](https://perday30kilo.github.io/posts/img/ddd-evans-04.webp)
# Factory
对象的创建本身可以是一个主要动作，但被创建的对象并不适合承担复杂的装配操作，将这些职责混在一起可能产生难以理解的拙劣设计。让客户直接去创建对象又会使得客户的设计陷入混乱，并破坏了Aggregate的封装，从而导致客户与被创建的对象的实现之间产生紧密的耦合。
Factory是正解。   

# Repository
Repository是一个简单的封装概念，用来封装数据库检索技术，让我们将注意力拉回到模型上。      
在概念层次上与领域模型紧密联系在一起。   
优点：
1. 为客户提供了一个简单的模型，可以用来获取持久化对象并管理他们的生命周期
1. 它使应用程序和领域设计和数据库持久化技术解耦

注意： Repository一般不会去开启事务，而是将事务的控制权留给客户。即客户在应用层去控制。




